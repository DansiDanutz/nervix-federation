/**
 * TON Connect Proof Verification Service
 * 
 * Implements the tonProof protocol for wallet-based authentication.
 * Reference: https://docs.ton.org/v3/guidelines/ton-connect/verifying-signed-in-users
 */
import { sha256, getSecureRandomBytes } from "@ton/crypto";
import { Address, Cell, contractAddress, loadStateInit } from "@ton/ton";
import { Buffer } from "buffer";
import nacl from "tweetnacl";

const TON_PROOF_PREFIX = "ton-proof-item-v2/";
const TON_CONNECT_PREFIX = "ton-connect";
const VALID_AUTH_TIME = 15 * 60; // 15 minutes

// ─── Nonce Store (in-memory, short-lived) ──────────────────────────────────
// In production you'd use Redis or DB. For now, in-memory with TTL cleanup.
const nonceStore = new Map<string, { createdAt: number }>();

// Clean up expired nonces every 5 minutes
setInterval(() => {
  const now = Date.now();
  for (const [nonce, data] of Array.from(nonceStore.entries())) {
    if (now - data.createdAt > VALID_AUTH_TIME * 1000) {
      nonceStore.delete(nonce);
    }
  }
}, 5 * 60 * 1000);

/**
 * Generate a random payload (nonce) for the client to include in tonProof.
 * The nonce is stored server-side and validated during verification.
 */
export async function generatePayload(): Promise<string> {
  const randomBytes = await getSecureRandomBytes(32);
  const nonce = Buffer.from(randomBytes).toString("hex");
  nonceStore.set(nonce, { createdAt: Date.now() });
  return nonce;
}

/**
 * Verify that a nonce was generated by this server and hasn't expired.
 */
export function verifyNonce(nonce: string): boolean {
  const entry = nonceStore.get(nonce);
  if (!entry) return false;
  const now = Date.now();
  if (now - entry.createdAt > VALID_AUTH_TIME * 1000) {
    nonceStore.delete(nonce);
    return false;
  }
  // Consume the nonce (one-time use)
  nonceStore.delete(nonce);
  return true;
}

/**
 * Extract public key from walletStateInit.
 * Supports standard wallet contracts (v1-v4, w5).
 */
function tryParsePublicKey(stateInit: ReturnType<typeof loadStateInit>): Buffer | null {
  try {
    if (!stateInit.data) return null;
    const dataSlice = stateInit.data.beginParse();
    // Most TON wallets store: seqno (32 bits) then public key (256 bits)
    // Some (like W5) store: is_signature_allowed (1 bit) + seqno (32 bits) + wallet_id (32 bits) + public_key (256 bits)
    // Try the common pattern first: skip first 32 bits (seqno), read 256 bits
    const bits = dataSlice.remainingBits;
    if (bits >= 32 + 256) {
      dataSlice.skip(32); // seqno or subwallet_id
      // Check if we have enough bits for another skip (wallet v4 has subwallet_id)
      if (bits >= 32 + 32 + 256) {
        // Could be v4 (seqno + subwallet_id + pubkey) or v3 (subwallet_id + seqno + pubkey)
        // Try reading 256 bits as pubkey
        const maybePubkey = Buffer.from(dataSlice.loadBuffer(32));
        // If this looks like a valid 32-byte key, return it
        if (maybePubkey.length === 32) return maybePubkey;
      }
      // Fallback: re-parse and try simpler layout
      const dataSlice2 = stateInit.data!.beginParse();
      dataSlice2.skip(32);
      return Buffer.from(dataSlice2.loadBuffer(32));
    }
    return null;
  } catch {
    return null;
  }
}

/**
 * The proof payload sent from the client after TON Connect wallet signs.
 */
export interface TonProofPayload {
  address: string;
  network: string; // "-239" for mainnet, "-3" for testnet
  public_key: string; // hex
  proof: {
    timestamp: number;
    domain: {
      lengthBytes: number;
      value: string;
    };
    signature: string; // base64
    payload: string; // the nonce we generated
    state_init: string; // base64 encoded cell
  };
}

/**
 * Verify a TON Connect proof-of-ownership.
 * 
 * Steps:
 * 1. Parse stateInit and extract public key
 * 2. Verify public key matches claimed public_key
 * 3. Verify address matches stateInit hash
 * 4. Check domain is allowed
 * 5. Check timestamp is recent
 * 6. Reconstruct and verify the Ed25519 signature
 */
export async function verifyTonProof(
  payload: TonProofPayload,
  allowedDomains: string[]
): Promise<{ valid: boolean; address: string; publicKey: string; error?: string }> {
  try {
    // Parse stateInit
    const stateInit = loadStateInit(
      Cell.fromBase64(payload.proof.state_init).beginParse()
    );

    // Extract public key from stateInit
    let publicKey = tryParsePublicKey(stateInit);
    if (!publicKey) {
      return { valid: false, address: payload.address, publicKey: payload.public_key, error: "Cannot extract public key from stateInit" };
    }

    // Verify public key matches claimed key
    const wantedPublicKey = Buffer.from(payload.public_key, "hex");
    if (!publicKey.equals(wantedPublicKey)) {
      return { valid: false, address: payload.address, publicKey: payload.public_key, error: "Public key mismatch" };
    }

    // Verify address matches stateInit
    const wantedAddress = Address.parse(payload.address);
    const derivedAddress = contractAddress(wantedAddress.workChain, stateInit);
    if (!derivedAddress.equals(wantedAddress)) {
      return { valid: false, address: payload.address, publicKey: payload.public_key, error: "Address does not match stateInit" };
    }

    // Check domain
    if (!allowedDomains.some(d => payload.proof.domain.value.includes(d))) {
      return { valid: false, address: payload.address, publicKey: payload.public_key, error: `Domain not allowed: ${payload.proof.domain.value}` };
    }

    // Check timestamp freshness
    const now = Math.floor(Date.now() / 1000);
    if (now - VALID_AUTH_TIME > payload.proof.timestamp) {
      return { valid: false, address: payload.address, publicKey: payload.public_key, error: "Proof expired" };
    }

    // Reconstruct the signed message
    const address = wantedAddress;
    const wc = Buffer.alloc(4);
    wc.writeUInt32BE(address.workChain, 0);

    const ts = Buffer.alloc(8);
    ts.writeBigUInt64LE(BigInt(payload.proof.timestamp), 0);

    const dl = Buffer.alloc(4);
    dl.writeUInt32LE(payload.proof.domain.lengthBytes, 0);

    // message = utf8_encode("ton-proof-item-v2/") ++ Address ++ AppDomain ++ Timestamp ++ Payload
    const msg = Buffer.concat([
      Buffer.from(TON_PROOF_PREFIX),
      wc,
      address.hash,
      dl,
      Buffer.from(payload.proof.domain.value),
      ts,
      Buffer.from(payload.proof.payload),
    ]);

    const msgHash = Buffer.from(await sha256(msg));

    // signature = Ed25519Sign(privkey, sha256(0xffff ++ utf8_encode("ton-connect") ++ sha256(message)))
    const fullMsg = Buffer.concat([
      Buffer.from([0xff, 0xff]),
      Buffer.from(TON_CONNECT_PREFIX),
      msgHash,
    ]);

    const result = Buffer.from(await sha256(fullMsg));
    const signature = Buffer.from(payload.proof.signature, "base64");

    const isValid = nacl.sign.detached.verify(result, signature, publicKey);

    return {
      valid: isValid,
      address: address.toString(),
      publicKey: payload.public_key,
      error: isValid ? undefined : "Signature verification failed",
    };
  } catch (e: any) {
    return {
      valid: false,
      address: payload.address,
      publicKey: payload.public_key,
      error: `Verification error: ${e.message || String(e)}`,
    };
  }
}
